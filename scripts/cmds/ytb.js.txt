const axios = require("axios");
const ytdl = require("@distube/ytdl-core");
const fs = require("fs-extra");
const ffmpeg = require("fluent-ffmpeg");
const { getStreamFromURL, downloadFile, formatNumber } = global.utils;

// Enhanced ytdl-core with better error handling
async function getYoutubeInfo(videoId) {
	const options = {
		requestOptions: {
			headers: {
				'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
			}
		}
	};

	try {
		return await ytdl.getInfo(videoId, options);
	} catch (err) {
		console.error("First attempt failed, trying alternative method:", err.message);
		// Try with different quality if first attempt fails
		return await ytdl.getInfo(videoId, {
			...options,
			quality: 'lowestvideo+lowestaudio'
		});
	}
}

async function getStreamAndSize(url, path = "") {
	const response = await axios({
		method: "GET",
		url,
		responseType: "stream",
		headers: {
			'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
			'Range': 'bytes=0-'
		}
	});
	if (path)
		response.data.path = path;
	const totalLength = response.headers["content-length"];
	return {
		stream: response.data,
		size: totalLength
	};
}

async function compressVideo(inputPath, outputPath) {
	return new Promise((resolve, reject) => {
		ffmpeg(inputPath)
			.videoCodec('libx264')
			.audioCodec('aac')
			.outputOptions([
				'-crf 28', // Quality level (lower is better)
				'-preset fast', // Faster encoding
				'-movflags +faststart', // Enable streaming
				'-vf scale=640:-2', // Scale to 640px width
				'-b:v 800k', // Video bitrate
				'-b:a 128k', // Audio bitrate
				'-threads 4' // Use multiple threads
			])
			.on('start', (cmd) => console.log('FFmpeg command:', cmd))
			.on('progress', (progress) => console.log('Processing:', progress.frames + ' frames'))
			.on('error', (err) => {
				console.error('FFmpeg error:', err.message);
				reject(err);
			})
			.on('end', () => {
				console.log('Compression finished');
				resolve(outputPath);
			})
			.save(outputPath);
	});
}

module.exports = {
	config: {
		name: "ytb",
		version: "1.18",
		author: "NTKhang",
		countDown: 5,
		role: 0,
		description: {
			vi: "Táº£i video, audio hoáº·c xem thÃ´ng tin video trÃªn YouTube",
			en: "Download video, audio or view video information on YouTube"
		},
		category: "media",
		guide: {
			vi: "   {pn} [video|-v] [<tÃªn video>|<link video>]: dÃ¹ng Ä‘á»ƒ táº£i video tá»« youtube."
				+ "\n   {pn} [audio|-a] [<tÃªn video>|<link video>]: dÃ¹ng Ä‘á»ƒ táº£i audio tá»« youtube"
				+ "\n   {pn} [info|-i] [<tÃªn video>|<link video>]: dÃ¹ng Ä‘á»ƒ xem thÃ´ng tin video tá»« youtube"
				+ "\n   VÃ­ dá»¥:"
				+ "\n    {pn} -v Fallen Kingdom"
				+ "\n    {pn} -a Fallen Kingdom"
				+ "\n    {pn} -i Fallen Kingdom",
			en: "   {pn} [video|-v] [<video name>|<video link>]: use to download video from youtube."
				+ "\n   {pn} [audio|-a] [<video name>|<video link>]: use to download audio from youtube"
				+ "\n   {pn} [info|-i] [<video name>|<video link>]: use to view video information from youtube"
				+ "\n   Example:"
				+ "\n    {pn} -v Fallen Kingdom"
				+ "\n    {pn} -a Fallen Kingdom"
				+ "\n    {pn} -i Fallen Kingdom"
		}
	},

	langs: {  
		vi: {  
			error: "âŒ ÄÃ£ xáº£y ra lá»—i: %1",  
			noResult: "â­• KhÃ´ng cÃ³ káº¿t quáº£ tÃ¬m kiáº¿m nÃ o phÃ¹ há»£p vá»›i tá»« khÃ³a %1",  
			choose: "%1Reply tin nháº¯n vá»›i sá»‘ Ä‘á»ƒ chá»n hoáº·c ná»™i dung báº¥t kÃ¬ Ä‘á»ƒ gá»¡",  
			video: "video",  
			audio: "Ã¢m thanh",  
			downloading: "â¬‡ï¸ Äang táº£i xuá»‘ng %1 \"%2\"",  
			downloading2: "â¬‡ï¸ Äang táº£i xuá»‘ng %1 \"%2\"\nðŸ”ƒ Tá»‘c Ä‘á»™: %3MB/s\nâ¸ï¸ ÄÃ£ táº£i: %4/%5MB (%6%)\nâ³ Æ¯á»›c tÃ­nh thá»i gian cÃ²n láº¡i: %7 giÃ¢y",  
			compressing: "ðŸ” Äang nÃ©n video Ä‘á»ƒ giáº£m dung lÆ°á»£ng...",
			noVideo: "â­• Ráº¥t tiáº¿c, khÃ´ng thá»ƒ táº£i video nÃ y sau khi nÃ©n",  
			noAudio: "â­• Ráº¥t tiáº¿c, khÃ´ng tÃ¬m tháº¥y audio nÃ o cÃ³ dung lÆ°á»£ng nhá» hÆ¡n 26MB",  
			info: "ðŸ’  TiÃªu Ä‘á»: %1\nðŸª Channel: %2\nðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Subscriber: %3\nâ± Thá»i gian video: %4\nðŸ‘€ LÆ°á»£t xem: %5\nðŸ‘ LÆ°á»£t thÃ­ch: %6\nðŸ†™ NgÃ y táº£i lÃªn: %7\nðŸ”  ID: %8\nðŸ”— Link: %9",  
			listChapter: "\nðŸ“– Danh sÃ¡ch phÃ¢n Ä‘oáº¡n: %1\n"  
		},  
		en: {  
			error: "âŒ An error occurred: %1",  
			noResult: "â­• No search results match the keyword %1",  
			choose: "%1Reply to the message with a number to choose or any content to cancel",  
			video: "video",  
			audio: "audio",  
			downloading: "â¬‡ï¸ Downloading %1 \"%2\"",  
			downloading2: "â¬‡ï¸ Downloading %1 \"%2\"\nðŸ”ƒ Speed: %3MB/s\nâ¸ï¸ Downloaded: %4/%5MB (%6%)\nâ³ Estimated time remaining: %7 seconds",  
			compressing: "ðŸ” Compressing video to reduce size...",
			noVideo: "â­• Sorry, couldn't download this video even after compression",  
			noAudio: "â­• Sorry, no audio was found with a size less than 26MB",  
			info: "ðŸ’  Title: %1\nðŸª Channel: %2\nðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Subscriber: %3\nâ± Video duration: %4\nðŸ‘€ View count: %5\nðŸ‘ Like count: %6\nðŸ†™ Upload date: %7\nðŸ”  ID: %8\nðŸ”— Link: %9",  
			listChapter: "\nðŸ“– List chapter: %1\n"  
		}  
	},  

	onStart: async function ({ args, message, event, commandName, getLang }) {  
		let type;  
		switch (args[0]) {  
			case "-v":  
			case "video":  
				type = "video";  
				break;  
			case "-a":  
			case "-s":  
			case "audio":  
			case "sing":  
				type = "audio";  
				break;  
			case "-i":  
			case "info":  
				type = "info";  
				break;  
			default:  
				return message.SyntaxError();  
		}  

		const checkurl = /^(?:https?:\/\/)?(?:m\.|www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=|shorts\/))((\w|-){11})(?:\S+)?$/;  
		const urlYtb = checkurl.test(args[1]);  

		if (urlYtb) {  
			const infoVideo = await getVideoInfo(args[1]);  
			handle({ type, infoVideo, message, downloadFile, getLang });  
			return;  
		}  

		let keyWord = args.slice(1).join(" ");  
		keyWord = keyWord.includes("?feature=share") ? keyWord.replace("?feature=share", "") : keyWord;  
		const maxResults = 6;  

		let result;  
		try {  
			result = (await search(keyWord)).slice(0, maxResults);  
		}  
		catch (err) {  
			return message.reply(getLang("error", err.message));  
		}  
		if (result.length == 0)  
			return message.reply(getLang("noResult", keyWord));  
		let msg = "";  
		let i = 1;  
		const thumbnails = [];  
		const arrayID = [];  

		for (const info of result) {  
			thumbnails.push(getStreamFromURL(info.thumbnail));  
			msg += `${i++}. ${info.title}\nTime: ${info.time}\nChannel: ${info.channel.name}\n\n`;  
		}  

		message.reply({  
			body: getLang("choose", msg),  
			attachment: await Promise.all(thumbnails)  
		}, (err, info) => {  
			global.GoatBot.onReply.set(info.messageID, {  
				commandName,  
				messageID: info.messageID,  
				author: event.senderID,  
				arrayID,  
				result,  
				type  
			});  
		});  
	},  

	onReply: async ({ event, api, Reply, message, getLang }) => {  
		const { result, type } = Reply;  
		const choice = event.body;  
		if (!isNaN(choice) && choice <= 6) {  
			const infoChoice = result[choice - 1];  
			const idvideo = infoChoice.id;  
			const infoVideo = await getVideoInfo(idvideo);  
			api.unsendMessage(Reply.messageID);  
			await handle({ type, infoVideo, message, getLang });  
		}  
		else  
			api.unsendMessage(Reply.messageID);  
	}
};

async function handle({ type, infoVideo, message, getLang }) {
	const { title, videoId } = infoVideo;

	if (type == "video") {  
		const MAX_SIZE = 83 * 1024 * 1024; // 83MB Facebook limit
		const msgSend = message.reply(getLang("downloading", getLang("video"), title));

		try {
			const info = await getYoutubeInfo(videoId);
			const formats = info.formats
				.filter(f => f.hasVideo && f.hasAudio)
				.sort((a, b) => a.bitrate - b.bitrate); // Try lowest quality first

			for (const format of formats) {
				try {
					const tempPath = `${__dirname}/tmp/${videoId}_raw_${Date.now()}.mp4`;
					const compressedPath = `${__dirname}/tmp/${videoId}_compressed_${Date.now()}.mp4`;

					// Download video
					const stream = ytdl.downloadFromInfo(info, { format });
					const writeStream = fs.createWriteStream(tempPath);
					stream.pipe(writeStream);

					await new Promise((resolve, reject) => {
						writeStream.on('finish', resolve);
						writeStream.on('error', reject);
					});

					// Compress video
					message.reply(getLang("compressing"));
					await compressVideo(tempPath, compressedPath);

					// Check size
					const stats = fs.statSync(compressedPath);
					if (stats.size > MAX_SIZE) {
						fs.unlinkSync(tempPath);
						fs.unlinkSync(compressedPath);
						continue; // Try next format
					}

					// Send video
					await message.reply({
						body: title,
						attachment: fs.createReadStream(compressedPath)
					});

					// Clean up
					fs.unlinkSync(tempPath);
					fs.unlinkSync(compressedPath);
					message.unsend((await msgSend).messageID);
					return;

				} catch (err) {
					console.error("Format attempt failed:", format.qualityLabel, err.message);
					continue;
				}
			}

			message.reply(getLang("noVideo"));
		} catch (err) {
			console.error("Video download failed:", err);
			message.reply(getLang("error", "Failed to download video. Please try again later."));
		}
	}  
	else if (type == "audio") {  
		const MAX_SIZE = 27262976; // 26MB
		const msgSend = message.reply(getLang("downloading", getLang("audio"), title));  

		try {
			const info = await getYoutubeInfo(videoId);
			const format = info.formats
				.filter(f => f.hasAudio && !f.hasVideo)
				.sort((a, b) => a.bitrate - b.bitrate) // Lowest quality first
				.find(f => f.contentLength && f.contentLength < MAX_SIZE);

			if (!format) {
				return message.reply(getLang("noAudio"));
			}

			const tempPath = `${__dirname}/tmp/${videoId}_${Date.now()}.mp3`;
			const stream = ytdl.downloadFromInfo(info, { format });
			const writeStream = fs.createWriteStream(tempPath);
			stream.pipe(writeStream);

			await new Promise((resolve, reject) => {
				writeStream.on('finish', resolve);
				writeStream.on('error', reject);
			});

			// Check size
			const stats = fs.statSync(tempPath);
			if (stats.size > MAX_SIZE) {
				fs.unlinkSync(tempPath);
				return message.reply(getLang("noAudio"));
			}

			// Send audio
			await message.reply({
				body: title,
				attachment: fs.createReadStream(tempPath)
			});

			// Clean up
			fs.unlinkSync(tempPath);
			message.unsend((await msgSend).messageID);

		} catch (err) {
			console.error("Audio download failed:", err);
			message.reply(getLang("error", "Failed to download audio. Please try again later."));
		}
	}  
	else if (type == "info") {  
		const { title, lengthSeconds, viewCount, videoId, uploadDate, likes, channel } = infoVideo;  

		const hours = Math.floor(lengthSeconds / 3600);  
		const minutes = Math.floor(lengthSeconds % 3600 / 60);  
		const seconds = Math.floor(lengthSeconds % 3600 % 60);  
		const time = `${hours ? hours + ":" : ""}${minutes < 10 ? "0" + minutes : minutes}:${seconds < 10 ? "0" + seconds : seconds}`;  
		let msg = getLang("info", title, channel.name, formatNumber(channel.subscriberCount || 0), time, formatNumber(viewCount), formatNumber(likes), uploadDate, videoId, `https://youtu.be/${videoId}`);  

		message.reply({  
			body: msg,  
			attachment: await Promise.all([  
				getStreamFromURL(infoVideo.thumbnails[infoVideo.thumbnails.length - 1].url),  
				getStreamFromURL(infoVideo.channel.thumbnails[infoVideo.channel.thumbnails.length - 1].url)  
			])  
		});  
	}
}

async function search(keyWord) {
	try {
		const url = `https://www.youtube.com/results?search_query=${encodeURIComponent(keyWord)}`;
		const res = await axios.get(url, {
			headers: {
				'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
			}
		});

		const getJson = JSON.parse(res.data.split("ytInitialData = ")[1].split(";</script>")[0]);
		const videos = getJson.contents.twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer.contents[0].itemSectionRenderer.contents;
		const results = [];

		for (const video of videos) {
			if (video.videoRenderer?.lengthText?.simpleText) {
				results.push({
					id: video.videoRenderer.videoId,
					title: video.videoRenderer.title.runs[0].text,
					thumbnail: video.videoRenderer.thumbnail.thumbnails.pop().url,
					time: video.videoRenderer.lengthText.simpleText,
					channel: {
						id: video.videoRenderer.ownerText.runs[0].navigationEndpoint.browseEndpoint.browseId,
						name: video.videoRenderer.ownerText.runs[0].text,
						thumbnail: video.videoRenderer.channelThumbnailSupportedRenderers.channelThumbnailWithLinkRenderer.thumbnail.thumbnails.pop().url.replace(/s[0-9]+-c/g, '-c')
					}
				});
			}
		}
		return results;
	}
	catch (e) {
		console.error("Search error:", e);
		const error = new Error("Cannot search video");
		error.code = "SEARCH_VIDEO_ERROR";
		throw error;
	}
}

async function getVideoInfo(id) {
	// Extract ID from URL if needed
	id = id.replace(/(>|<)/gi, '').split(/(vi\/|v=|\/v\/|youtu\.be\/|\/embed\/|\/shorts\/)/);
	id = id[2] !== undefined ? id[2].split(/[^0-9a-z_-]/i)[0] : id[0];

	try {
		const { data: html } = await axios.get(`https://youtu.be/${id}?hl=en`, {  
			headers: {  
				'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'  
			}  
		});  

		const json = JSON.parse(html.match(/var ytInitialPlayerResponse = (.*?});/)[1]);  
		const json2 = JSON.parse(html.match(/var ytInitialData = (.*?});/)[1]);  
		const { title, lengthSeconds, viewCount, videoId, thumbnail, author } = json.videoDetails;  

		let getChapters = [];  
		try {  
			getChapters = json2.playerOverlays.playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer.playerBar.multiMarkersPlayerBarRenderer.markersMap
				.find(x => x.key == "DESCRIPTION_CHAPTERS" && x.value.chapters)?.value.chapters || [];  
		} catch (e) {}  

		const owner = json2.contents.twoColumnWatchNextResults.results.results.contents
			.find(x => x.videoSecondaryInfoRenderer)?.videoSecondaryInfoRenderer?.owner;  

		if (!owner) {
			throw new Error("Could not get video owner information");
		}

		return {  
			videoId,  
			title,  
			video_url: `https://youtu.be/${videoId}`,  
			lengthSeconds: lengthSeconds.match(/\d+/)[0],  
			viewCount: viewCount.match(/\d+/)[0],  
			uploadDate: json.microformat.playerMicroformatRenderer.uploadDate,  
			likes: json2.contents.twoColumnWatchNextResults.results.results.contents
				.find(x => x.videoPrimaryInfoRenderer)?.videoPrimaryInfoRenderer?.videoActions?.menuRenderer?.topLevelButtons
				?.find(x => x.segmentedLikeDislikeButtonViewModel)?.segmentedLikeDislikeButtonViewModel?.likeButtonViewModel
				?.likeButtonViewModel?.toggleButtonViewModel?.toggleButtonViewModel?.defaultButtonViewModel?.buttonViewModel
				?.accessibilityLabel?.replace(/\.|,/g, '')?.match(/\d+/)?.[0] || 0,  
			chapters: getChapters.map((x, i) => {  
				const start_time = x.chapterRenderer.timeRangeStartMillis;  
				const end_time = getChapters[i + 1]?.chapterRenderer?.timeRangeStartMillis || lengthSeconds.match(/\d+/)[0] * 1000;  

				return {  
					title: x.chapterRenderer.title.simpleText,  
					start_time_ms: start_time,  
					start_time: start_time / 1000,  
					end_time_ms: end_time - start_time + start_time,  
					end_time: (end_time - start_time + start_time) / 1000  
				};  
			}),  
			thumbnails: thumbnail.thumbnails,  
			author: author,  
			channel: {  
				id: owner.videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId,  
				username: owner.videoOwnerRenderer.navigationEndpoint.browseEndpoint.canonicalBaseUrl,  
				name: owner.videoOwnerRenderer.title.runs[0].text,  
				thumbnails: owner.videoOwnerRenderer.thumbnail.thumbnails,  
				subscriberCount: parseAbbreviatedNumber(owner.videoOwnerRenderer.subscriberCountText?.simpleText || "0")  
			}  
		};  
	} catch (err) {
		console.error("Error getting video info:", err);
		throw new Error("Could not get video information");
	}
}

function parseAbbreviatedNumber(string) {
	if (!string) return 0;

	const match = string
		.replace(',', '.')
		.replace(' ', '')
		.match(/([\d,.]+)([MK]?)/);

	if (match) {
		let [, num, multi] = match;
		num = parseFloat(num);
		return Math.round(multi === 'M' ? num * 1000000 :
			multi === 'K' ? num * 1000 : num);
	}
	return 0;
}